import fs from 'node:fs/promises';
import path from 'node:path';
import log from 'electron-log';

/**
 * EntryPoint scripts for dependency and service operations
 */
export interface EntryPoint {
  check: string;  // Script path for checking dependency status
  install: string; // Script path for installing dependency
  start: string;   // Script path for starting web service
  llmPrompt?: string;       // LLM prompt path for CN region
  llmPromptIntl?: string;  // LLM prompt path for international region
}

/**
 * Result session file generated by entryPoint scripts
 */
export interface ResultSessionFile {
  exitCode: number;
  stdout: string;
  stderr: string;
  duration: number;
  timestamp: string;
  success: boolean;
  errorMessage?: string;
  version?: string;
  url?: string;     // Service URL (for start script)
  port?: number;    // Service port (for start script)
}

/**
 * Parsed result from entryPoint script execution
 */
export interface ParsedResult {
  success: boolean;
  version?: string;
  errorMessage?: string;
  rawOutput: string;
  url?: string;     // Service URL (for start result)
  port?: number;    // Service port (for start result)
}

/**
 * Installation result from entryPoint install script
 */
export interface InstallResult {
  success: boolean;
  resultSession: ResultSessionFile;
  parsedResult: ParsedResult;
  installHint?: string;
}

/**
 * Start result from entryPoint start script
 */
export interface StartResult {
  success: boolean;
  resultSession: ResultSessionFile;
  parsedResult: ParsedResult;
  url?: string;     // Service URL if started successfully
  port?: number;    // Service port if started successfully
}

/**
 * Manifest schema version 1.0
 */
export interface Manifest {
  $schema: string;
  manifestVersion: string;
  package: {
    name: string;
    version: string;
    buildTimestamp: string;
    gitCommit: string;
  };
  dependencies: Record<string, Dependency>;
  entryPoint?: EntryPoint;
  filesReference: {
    path: string;
    checksum: string;
    format: string;
    count: number;
  };
  metadata: {
    description: string;
    author: string;
    license: string;
    homepage: string;
    documentation: string;
    repository: string;
  };
  npmConfig?: NpmConfig;
  donationInfo?: DonationInfo;
  packageMetadata?: PackageMetadata;
}

/**
 * NPM mirror configuration
 */
export interface NpmConfig {
  mirrors: {
    china: string;
    global: string;
  };
  region?: 'china' | 'global';
}

/**
 * Donation information
 */
export interface DonationInfo {
  url?: string;
  qrCode?: string;
  description?: string;
}

/**
 * Package metadata for external dependencies
 */
export interface PackageMetadata {
  npm?: Record<string, NpmPackageInfo>;
}

/**
 * NPM package metadata
 */
export interface NpmPackageInfo {
  packageName: string;
  version?: string;
  commandName: string;
  description: string;
}

/**
 * Dependency definition from manifest
 */
export interface Dependency {
  version: DependencyVersion | DependencyVersionWithRuntime;
  installCommand?: InstallCommand;
  installHint?: string;
  checkCommand: string;
  type: DependencyTypeName;
  description: string;
}

/**
 * Version constraints
 */
export interface DependencyVersion {
  min: string;
  max: string;
  exact?: string;
  recommended?: string;
  description: string;
}

/**
 * Version constraints with runtime info
 */
export interface DependencyVersionWithRuntime extends DependencyVersion {
  runtime?: {
    min: string;
    max: string;
    recommended: string;
    description: string;
  };
}

/**
 * Dependency type names from manifest
 */
export type DependencyTypeName = 'npm' | 'system-runtime' | 'system-requirement';

/**
 * Region type for install commands
 */
export type Region = 'china' | 'global';

/**
 * Platform type for install commands
 */
export type Platform = 'windows' | 'macos' | 'linux';

/**
 * Regional install command (simple structure)
 */
export interface RegionalInstallCommand {
  china: string;
  global: string;
  isRegional: true;
}

/**
 * Platform regional install command (nested structure)
 */
export interface PlatformRegionalInstallCommand {
  windows?: {
    china: string;
    global: string;
  };
  macos?: {
    china: string;
    global: string;
  };
  linux?: {
    china: string;
    global: string;
  };
}

/**
 * Install command type (union type)
 */
export type InstallCommand =
  | string
  | RegionalInstallCommand
  | PlatformRegionalInstallCommand;

/**
 * Parsed dependency for checking
 */
export interface ParsedDependency {
  key: string;
  name: string;
  type: DependencyTypeName;
  versionConstraints: VersionConstraints;
  checkCommand: string;
  installCommand?: InstallCommand;
  installHint?: string;
  description: string;
}

/**
 * Parsed install command for execution
 */
export interface ParsedInstallCommand {
  command: string | null;  // Executable command, null means not auto-installable
  type: 'auto' | 'manual' | 'not-available';
  hint?: string;  // Manual install hint
}

/**
 * Version constraints for checking
 */
export interface VersionConstraints {
  min?: string;
  max?: string;
  exact?: string;
  recommended?: string;
  runtime?: {
    min?: string;
    max?: string;
    recommended?: string;
  };
}

/**
 * ManifestReader handles reading and parsing manifest.json files
 */
export class ManifestReader {
  /**
   * Read manifest.json from package installation directory
   * @param installPath - Path to the installed package directory
   * @returns Parsed Manifest object or null if not found
   */
  async readManifest(installPath: string): Promise<Manifest | null> {
    const manifestPath = path.join(installPath, 'manifest.json');

    try {
      log.info('[ManifestReader] Reading manifest:', manifestPath);

      // Check if file exists
      await fs.access(manifestPath);

      // Read file content
      const content = await fs.readFile(manifestPath, 'utf-8');

      // Parse JSON
      const manifest: Manifest = JSON.parse(content);

      // Validate manifest version
      if (manifest.manifestVersion !== '1.0') {
        log.warn('[ManifestReader] Unsupported manifest version:', manifest.manifestVersion);
      }

      log.info('[ManifestReader] Manifest loaded successfully:', manifest.package.name, manifest.package.version);
      return manifest;
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        log.warn('[ManifestReader] manifest.json not found at:', manifestPath);
      } else {
        log.error('[ManifestReader] Failed to read manifest:', error);
      }
      return null;
    }
  }

  /**
   * Parse dependencies from manifest into checkable format
   * @param manifest - The manifest object
   * @returns Array of parsed dependencies
   */
  parseDependencies(manifest: Manifest): ParsedDependency[] {
    const dependencies: ParsedDependency[] = [];

    for (const [key, dep] of Object.entries(manifest.dependencies)) {
      // Skip system requirements as they're not checkable/installable dependencies
      if (dep.type === 'system-requirement') {
        continue;
      }

      const versionConstraints: VersionConstraints = {
        min: dep.version.min,
        max: dep.version.max,
        exact: dep.version.exact,
        recommended: dep.version.recommended,
      };

      // Check for runtime-specific version constraints
      if ('runtime' in dep.version) {
        versionConstraints.runtime = {
          min: dep.version.runtime?.min,
          max: dep.version.runtime?.max,
          recommended: dep.version.runtime?.recommended,
        };
      }

      dependencies.push({
        key,
        name: this.formatDependencyName(key),
        type: dep.type,
        versionConstraints,
        checkCommand: dep.checkCommand,
        installCommand: dep.installCommand,
        installHint: dep.installHint,
        description: dep.description,
      });
    }

    log.info('[ManifestReader] Parsed', dependencies.length, 'dependencies');
    return dependencies;
  }

  /**
   * Format dependency key to display name
   * @param key - Dependency key (e.g., "claudeCode", "dotnet")
   * @returns Formatted display name
   */
  private formatDependencyName(key: string): string {
    // Capitalize first letter and handle camelCase
    return key
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, (str) => str.toUpperCase())
      .trim();
  }


  /**
   * Read package metadata from manifest
   * @param manifest - The manifest object
   * @returns Package metadata or null if not available
   */
  readPackageMetadata(manifest: Manifest | null): PackageMetadata | null {
    if (!manifest?.packageMetadata) {
      log.warn('[ManifestReader] No package metadata found in manifest, using fallback');
      return null;
    }

    return manifest.packageMetadata;
  }

  /**
   * Read NPM config from manifest
   * @param manifest - The manifest object
   * @returns NPM config or default fallback values
   */
  readNpmConfig(manifest: Manifest | null): NpmConfig {
    const defaultConfig: NpmConfig = {
      mirrors: {
        china: 'https://registry.npmmirror.com',
        global: 'https://registry.npmjs.org',
      },
      region: 'global',
    };

    if (!manifest?.npmConfig) {
      log.warn('[ManifestReader] No NPM config found in manifest, using defaults');
      return defaultConfig;
    }

    // Ensure all required fields exist
    return {
      mirrors: {
        china: manifest.npmConfig.mirrors?.china || defaultConfig.mirrors.china,
        global: manifest.npmConfig.mirrors?.global || defaultConfig.mirrors.global,
      },
      region: manifest.npmConfig.region || defaultConfig.region,
    };
  }

  /**
   * Read donation info from manifest
   * @param manifest - The manifest object
   * @returns Donation info or null if not available
   */
  readDonationInfo(manifest: Manifest | null): DonationInfo | null {
    if (!manifest?.donationInfo) {
      return null;
    }

    return manifest.donationInfo;
  }

  /**
   * Get NPM package metadata by key from manifest
   * @param manifest - The manifest object
   * @param key - Package key (e.g., "claudeCode", "openspec")
   * @returns NPM package info or null if not found
   */
  getNpmPackageInfo(manifest: Manifest | null, key: string): NpmPackageInfo | null {
    const packageMetadata = this.readPackageMetadata(manifest);

    if (!packageMetadata?.npm) {
      log.warn('[ManifestReader] No NPM package metadata found in manifest');
      return null;
    }

    const npmInfo = packageMetadata.npm[key];
    if (!npmInfo) {
      log.warn('[ManifestReader] No NPM package info found for key:', key);
      return null;
    }

    return npmInfo;
  }

  /**
   * Get all NPM package metadata from manifest
   * @param manifest - The manifest object
   * @returns Record of NPM package info or empty object
   */
  getAllNpmPackageInfo(manifest: Manifest | null): Record<string, NpmPackageInfo> {
    const packageMetadata = this.readPackageMetadata(manifest);

    if (!packageMetadata?.npm) {
      return {};
    }

    return packageMetadata.npm;
  }

  /**
   * Parse EntryPoint from manifest
   * @param manifest - The manifest object
   * @returns EntryPoint object or null if not available
   */
  parseEntryPoint(manifest: Manifest | null): EntryPoint | null {
    if (!manifest?.entryPoint) {
      log.warn('[ManifestReader] No entryPoint found in manifest');
      return null;
    }

    return manifest.entryPoint;
  }
}

/**
 * Singleton instance for easy access
 */
export const manifestReader = new ManifestReader();
