name: Sync Release to Azure Storage

# This workflow is called by build.yml after a release is created.
on:
  workflow_call:
    inputs:
      release_tag:
        description: 'Release tag to sync'
        required: true
        type: string
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag to sync (empty for latest release)'
        required: false
        type: string

permissions:
  contents: read

jobs:
  sync-to-azure:
    name: Sync Release Assets to Azure Storage
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate SAS URL secret
        run: |
          if [ -z "${{ secrets.AZURE_BLOB_SAS_URL }}" ]; then
            echo "::error::AZURE_BLOB_SAS_URL secret not found. Please configure it in GitHub Secrets."
            exit 1
          fi
          echo "SAS URL secret found"

      - name: Determine release tag
        id: release_info
        run: |
          # From workflow_call input, or fetch latest for manual dispatch
          if [ -n "${{ inputs.release_tag }}" ]; then
            RELEASE_TAG="${{ inputs.release_tag }}"
          else
            RELEASE_TAG=$(gh release view --json tagName -q .tagName)
            echo "No tag specified, using latest release: ${RELEASE_TAG}"
          fi
          echo "tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "Release tag: ${RELEASE_TAG}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create download directory
        run: |
          mkdir -p ./release-assets
          echo "Created download directory: ./release-assets"

      - name: Download release assets
        run: |
          gh release download "${{ steps.release_info.outputs.tag }}" --dir ./release-assets --pattern "*"
          echo "Downloaded release assets:"
          ls -lah ./release-assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Azure CLI
        run: |
          echo "Installing Azure CLI..."
          # Ubuntu runner already has Azure CLI, but ensure it's available
          az version || curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

      - name: Parse SAS URL and extract storage info
        id: sas_info
        run: |
          SAS_URL="${{ secrets.AZURE_BLOB_SAS_URL }}"

          # Parse the SAS URL to extract storage account name and container
          # Format: https://<account>.blob.core.windows.net/<container>?<sas_token>

          # Extract account name (remove protocol and parse domain)
          ACCOUNT=$(echo "$SAS_URL" | sed -n 's|https://\([^.]*\)\.blob\.core\.windows\.net.*|\1|p')
          echo "account=${ACCOUNT}" >> $GITHUB_OUTPUT

          # Extract container name (between domain and query string)
          CONTAINER=$(echo "$SAS_URL" | sed -n 's|https://[^.]*\.blob\.core\.windows\.net/\([^?]*\).*|\1|p')
          echo "container=${CONTAINER}" >> $GITHUB_OUTPUT

          # Get the SAS token (everything after ?)
          SAS_TOKEN=$(echo "$SAS_URL" | sed -n 's|[^?]*\(?\.*\)|\1|p')
          # Store token as file to avoid issues with special characters
          echo "$SAS_TOKEN" > /tmp/sas_token.txt

          echo "Storage Account: ${ACCOUNT}"
          echo "Container: ${CONTAINER}"
          echo "SAS Token: [hidden]"

      - name: Upload to Azure Storage
        run: |
          # Set up Azure CLI authentication using SAS token
          ACCOUNT="${{ steps.sas_info.outputs.account }}"
          CONTAINER="${{ steps.sas_info.outputs.container }}"
          SAS_TOKEN=$(cat /tmp/sas_token.txt)

          # Upload files to versioned directory
          VERSION="${{ steps.release_info.outputs.tag }}"
          BLOB_PATH="${VERSION}/"

          echo "Uploading files to Azure Storage..."
          echo "Account: ${ACCOUNT}"
          echo "Container: ${CONTAINER}"
          echo "Path: ${BLOB_PATH}"

          # Upload each file using SAS URL authentication
          FILE_COUNT=0
          for file in ./release-assets/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "Uploading: ${filename}"

              # Build the blob URL with SAS token
              BLOB_URL="https://${ACCOUNT}.blob.core.windows.net/${CONTAINER}/${BLOB_PATH}${filename}${SAS_TOKEN}"

              # Upload using az storage blob upload with SAS authentication
              az storage blob upload \
                --account-name "${ACCOUNT}" \
                --container-name "${CONTAINER}" \
                --name "${BLOB_PATH}${filename}" \
                --file "$file" \
                --sas-token "${SAS_TOKEN}" \
                --overwrite || {
                  echo "::error::Failed to upload ${filename}"
                  exit 1
                }
              FILE_COUNT=$((FILE_COUNT + 1))
            fi
          done

          echo "Successfully uploaded ${FILE_COUNT} file(s) to Azure Storage"

      - name: Generate and upload index file
        run: |
          ACCOUNT="${{ steps.sas_info.outputs.account }}"
          CONTAINER="${{ steps.sas_info.outputs.container }}"
          SAS_TOKEN=$(cat /tmp/sas_token.txt)
          RELEASE_TAG="${{ steps.release_info.outputs.tag }}"

          echo "Generating index.json..."

          # Get GitHub Release published_at for fallback
          echo "Fetching GitHub Release publish time..."
          PUBLISHED_AT=$(gh release view "${RELEASE_TAG}" --json publishedAt -q .publishedAt)

          # Get all blobs and organize by version
          # Fixed: Correctly extract lastModified from properties.lastModified
          BLOBS=$(az storage blob list \
            --account-name "${ACCOUNT}" \
            --container-name "${CONTAINER}" \
            --sas-token "${SAS_TOKEN}" \
            --query "[].{name:name, lastModified:properties.lastModified, size:properties.contentLength}" \
            --output json)

          # Create JSON index with files organized by version
          # Use GitHub Release published_at as fallback if lastModified is null/empty
          INDEX_JSON=$(echo "$BLOBS" | jq --arg fallback_time "$PUBLISHED_AT" '{
            updatedAt: now,
            versions: [
              .[]
              | select(.name | contains("index.json") | not)
              | {
                  version: (.name | split("/")[0]),
                  name: (.name | split("/")[1:][-1]),
                  path: .name,
                  size: .size,
                  lastModified: (.lastModified // $fallback_time)
                }
            ]
            | group_by(.version)
            | map({
                version: .[0].version,
                files: [.[].name],
                assets: [
                  .[] | {
                    name: .name,
                    path: .path,
                    size: .size,
                    lastModified: (.lastModified // $fallback_time)
                  }
                ]
              })
            | sort_by(.version) | reverse
          }')

          echo "$INDEX_JSON" | jq -c . > index.json

          # 验证生成的 JSON 格式有效
          echo "Validating index.json..."
          if ! jq empty index.json; then
            echo "::error::Generated index.json is not valid JSON"
            exit 1
          fi
          echo "index.json validation passed"

          # Upload index.json
          echo "Uploading index.json..."
          az storage blob upload \
            --account-name "${ACCOUNT}" \
            --container-name "${CONTAINER}" \
            --name "index.json" \
            --file "index.json" \
            --sas-token "${SAS_TOKEN}" \
            --overwrite \
            --content-type "application/json"

          echo "Index file generated and uploaded successfully"
          echo "Summary:"
          echo "$INDEX_JSON" | jq -r '.versions | length' | xargs -I {} echo "  - {} version(s)"
          echo "$INDEX_JSON" | jq -r '.versions[].files | length' | paste -sd+ | bc | xargs -I {} echo "  - {} file(s) total"

      - name: Verify upload
        if: success()
        run: |
          ACCOUNT="${{ steps.sas_info.outputs.account }}"
          CONTAINER="${{ steps.sas_info.outputs.container }}"
          SAS_TOKEN=$(cat /tmp/sas_token.txt)
          VERSION="${{ steps.release_info.outputs.tag }}"
          BLOB_PATH="${VERSION}/"

          echo "Verifying uploaded files..."
          az storage blob list \
            --account-name "${ACCOUNT}" \
            --container-name "${CONTAINER}" \
            --prefix "${BLOB_PATH}" \
            --sas-token "${SAS_TOKEN}" \
            --query "[].name" \
            --output tsv

          echo "Verification complete!"

      - name: Report failure
        if: failure()
        run: |
          echo "::error::Failed to sync release assets to Azure Storage"
          echo "Please check:"
          echo "  1. AZURE_BLOB_SAS_URL secret is correctly configured"
          echo "  2. SAS token has 'Write' permissions"
          echo "  3. SAS token has not expired"
          echo "  4. Container exists in Azure Storage"
          exit 1

      - name: Export outputs
        if: always()
        run: |
          # Export outputs for notification job
          ACCOUNT="${{ steps.sas_info.outputs.account }}"
          VERSION="${{ steps.release_info.outputs.tag }}"

          # Count uploaded files
          FILE_COUNT=$(ls -1 ./release-assets/* 2>/dev/null | wc -l)

          # Build Azure Storage path
          BLOB_PATH="https://${ACCOUNT}.blob.core.windows.net/${{ steps.sas_info.outputs.container }}/${VERSION}/"

          echo "tag=${VERSION}" >> $GITHUB_OUTPUT
          echo "file_count=${FILE_COUNT}" >> $GITHUB_OUTPUT
          echo "blob_path=${BLOB_PATH}" >> $GITHUB_OUTPUT
          echo "storage_account=${ACCOUNT}" >> $GITHUB_OUTPUT

          echo "Exported outputs:"
          echo "  tag: ${VERSION}"
          echo "  file_count: ${FILE_COUNT}"
          echo "  blob_path: ${BLOB_PATH}"
          echo "  storage_account: ${ACCOUNT}"

  azure-sync-notification:
    name: Azure Sync Notification
    needs: sync-to-azure
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Determine sync status
        id: status
        run: |
          sync_result="${{ needs.sync-to-azure.result }}"

          if [ "${sync_result}" == "success" ]; then
            echo "status_icon=✅" >> $GITHUB_OUTPUT
            echo "status_text=成功" >> $GITHUB_OUTPUT
            echo "status_verb=已成功同步到" >> $GITHUB_OUTPUT
          else
            echo "status_icon=❌" >> $GITHUB_OUTPUT
            echo "status_text=失败" >> $GITHUB_OUTPUT
            echo "status_verb=同步到" >> $GITHUB_OUTPUT
          fi

      - name: Notify Feishu
        uses: HagiCode-org/haginotifier@v1.0.0
        with:
          message: |
            **Azure 同步${{ steps.status.outputs.status_text }}**

            发布资源${{ steps.status.outputs.status_verb }} Azure Storage

            版本: ${{ needs.sync-to-azure.outputs.tag }}
            上传文件: ${{ needs.sync-to-azure.outputs.file_count }} 个
            存储路径: ${{ needs.sync-to-azure.outputs.blob_path }}

            提交: `${{ github.sha }}`
            触发者: ${{ github.actor }}

            [查看详情](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          msg_type: 'post'
          title: 'Azure 同步${{ steps.status.outputs.status_text }} ${{ steps.status.outputs.status_icon }}'
        secrets: inherit
